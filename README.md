Проект по работе с ассинхронностью (прерываемыми функциями, задачами, шаблоном "Производитель-потребитель"), многопоточностью (пулы потоков, интерфейсы Runnable и Thread, побочные потоки, функции "Производитель" и "Потребитель"), аннотациями (стандартной библиотеки Kotlin и Java), рефлексией (добавление, изменение, удаление свойств, методов в класс), специализированными классами (class enum, data class, паттерн "Фабрика", паттерн "Строитель"), инкапсуляцией, абстрактным базовым классом, интерфейсами, функциями (указатели, декораторы, рекурсия, vararg) 

Аннотации и рефлексия
Использованы стандартные аннотации Kotlin: @Suppress, @Deprecated, @RequiresOptIn/@OptIn, @MustBeDocumented, @Target, @Retention.
Использованы стандартные аннотации Java: @Override, @FunctionalInterface, @NotNull/@Nullable.
Созданы собственные аннотации: @ImportantAPI, @Important, @Transport, @Drive, @Comment.
Через kotlin.reflect реализовано изменение поведения по аннотациям: поиск аннотаций у функций, выбор логики (например, предпросмотр/лог/пояснения), доступ к приватным членам через isAccessible, интроспекция методов, свойств, предков, аргументов и их типов.

Корутины (asynchrony)
Базовые конструкции: suspend-функции, launch, async/await, runBlocking, yield, delay.
Управление жизненным циклом: отмена (cancel, cancelAndJoin), обработка CancellationException, isActive, обработчик ошибок CoroutineExceptionHandler, иерархия через SupervisorJob.
Сценарии: массивы задач launch/async, сбор результатов awaitAll, разные контексты (Dispatchers.Default/IO), кооперативная отмена.
Реализован шаблон «производитель–потребитель» на корутинах (буфер/очередь, кооперативные паузы, обработка отмен).

Функциональный стиль
Три сигнатуры функций в трёх формах (обычная, анонимная, лямбда): () -> Unit, (Any) -> Any, (Any) -> Collection<Any>.
vararg, параметры по умолчанию, именованные аргументы.
HOF: функции, принимающие функции и возвращающие функции.
Декораторы: логирование, тайминг, мемоизация, а также параметризуемый retry(n); композиция декораторов; “указатели” на функции и динамический вызов с адаптерами по арности.

Рефлексия классов (отчётность по структуре)
Вывод списков: атрибутов/свойств, методов (включая приватные), предков.
Вывод аргументов и их типов у конкретного метода.
Попытка модификации свойств через KMutableProperty с проверками и обработкой ошибок.

Многопоточность на JVM (без корутин)
Запуск задач: через Runnable, наследование Thread, и Callable+Future.
Пулы потоков Executors, очередь завершений ExecutorCompletionService.
Сценарии отмены: “первый готов — остальные отменить”, “первые три — остальные отменить”, печать результатов по готовности, пауза остальных при каждом новом результате.
Синхронизация/координация: AtomicBoolean/AtomicLong, CountDownLatch, кооперативные прерывания.
Классический «producer–consumer» на потоках с ограниченным буфером и wait/notifyAll.

ООП на Kotlin
Интерфейсы, абстрактные классы, наследование, полиморфизм на коллекциях базового типа.
Компаньоны (companion object), в т.ч. @JvmStatic; модификаторы public/private/protected/internal.
Кастомные геттеры/сеттеры с валидацией и скрытым сеттером; безопасные приведения as?, проверки is, “умный” when.

Паттерны / модели данных
enum class c данными и методом форматирования.
data class c copy и сравнениями.
Фабрика (в т.ч. через компаньон).
Строитель (Builder) с валидацией и мини-DSL (laptop { … }).

Демонстрации поведения
Изменение логики по аннотациям (@Drive, @Comment, @Important*): извлечение метаданных, печать комментариев/версий, включение дополнительных шагов.
Обработка ошибок/отмен: перехват CancellationException, сценарии с каскадной отменой/приостановкой.
Производительность/кэширование: декораторы time и memo с повторными вызовами.
Интроспекция и модификация: вывод структур класса, попытки изменения свойств, доступ к приватным методам (контролируемо).

В этом проекте используется [Gradle](https://gradle.org/).
Для сборки и запуска приложения используйте окно инструментов *Gradle*, щёлкнув по значку Gradle на правой панели инструментов,
или запустите его непосредственно из терминала:
* Выполните `./gradlew run` для сборки и запуска приложения.
* Выполните `./gradlew build`, чтобы собрать только приложение.
* Выполните `./gradlew check` для запуска всех проверок, включая тесты.
* Выполните `./gradlew clean` для очистки всех результатов сборки.
Обратите внимание на использование Gradle Wrapper (`./gradlew`).
Это рекомендуемый способ использования Gradle в производственных проектах.
Этот проект следует предлагаемой многомодульной схеме и состоит из подпроектов `app` и `utils`.
Общая логика сборки была извлечена в плагин соглашения, расположенный в `buildSrc`.
Этот проект использует каталог версий (см. `gradle/libs.versions.toml`) для объявления и управления версиями зависимостей,
а также кэш сборки и кэш конфигурации (см. `gradle.properties`).
